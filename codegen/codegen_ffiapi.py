
file_header = \
"""//
// Copyright (C) 2020 Signal Messenger, LLC.
// All rights reserved.
//
// SPDX-License-Identifier: GPL-3.0-only
//

// Generated by zkgroup/codegen/codegen.py - do not edit

#![allow(non_snake_case)]

use super::simpleapi;
use std::slice;
"""

template_method_start = \
"""
#[no_mangle]
pub extern "C" fn %(function_name)s(
"""

template_method_decl_end = \
""") -> i32 {
"""

def get_args(params, commaAtEnd):
    s = ""
    for param in params:
        if param[0] != "int":
            s += "&" + param[1].snake() + ", "
        else:
            s += param[1].snake() + ", "

    if len(s) != 0 and not commaAtEnd:
        s = s[:-2]
    return s


def print_method(c, m, static):
    s = ""

    if c.wrap_class == None:
        class_name = c.class_name
    else:
        class_name = c.wrap_class

    function_name = "FFI_" + class_name.camel() + "_" + m.method_name.lower_camel()
    s += template_method_start % {"function_name": function_name}

    # decl
    if not static:
        s += "    " + class_name.lower_camel() + ": *const u8,\n"
        s += "    " + class_name.lower_camel() + "Len: u64,\n"
    for param in m.params:
        if param[0] != "int":
            s += "    " + param[1].lower_camel() + ": *const u8,\n"
            s += "    " + param[1].lower_camel() + "Len: u64,\n"
        else:
            s += "    " + param[1].lower_camel() + ": u32,\n"
    if m.return_type != "boolean": 
        s += "    " + m.return_name.lower_camel() + "Out: *mut u8,\n" 
        s += "    " + m.return_name.lower_camel() + "Len: u64,\n" 
    s += template_method_decl_end

    # body
    if not static:
        s += "    let " + class_name.snake() + ": &[u8] = unsafe { slice::from_raw_parts(%s, %sLen as usize) };\n" % (class_name.lower_camel(), class_name.lower_camel())
    for param in m.params:
        if param[0] != "int":
            s += "    let " + param[1].snake() + ": &[u8] = unsafe { slice::from_raw_parts(%s, %sLen as usize) };\n" % (param[1].lower_camel(), param[1].lower_camel())
        else:
            s += "    let " + param[1].snake() + " = %s as u32;\n" % param[1].lower_camel();
    if m.return_type != "boolean":
        s += "    let %s: &mut [u8] = unsafe { slice::from_raw_parts_mut(%sOut, %sLen as usize) };\n" % (m.return_name.snake(), m.return_name.lower_camel(), m.return_name.lower_camel())

    if not static:
        if m.return_type != "boolean":
            s += """\n    simpleapi::%s_%s(%s, %s %s)\n""" % (class_name.camel(), m.method_name.lower_camel(), class_name.snake(), get_args(m.params, True), m.return_name.snake())
        else:
            s += """\n    simpleapi::%s_%s(%s, %s)\n""" % (class_name.camel(), m.method_name.lower_camel(), class_name.snake(), get_args(m.params, False))
    else:
        if m.return_type != "boolean":
            s += """\n    simpleapi::%s_%s(%s %s)\n""" % (class_name.camel(), m.method_name.lower_camel(), get_args(m.params, True), m.return_name.snake())
        else:
            s += """\n    simpleapi::%s_%s(%s)\n""" % (class_name.camel(), m.method_name.lower_camel(), get_args(m.params, False))
    s += "}\n"

    return s

def print_class(c):
    s = ""
    for method in c.static_methods:
        s += print_method(c, method, True)
    for method in c.methods:
        s += print_method(c, method, False)
    return s


def produce_output(classes):
    s = file_header
    for c in classes:
        s += print_class(c)
    f = open("ffiapi/ffiapi.rs", "w")
    f.write(s)
    f.close()

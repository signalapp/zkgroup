
file_header = \
"""//
// Copyright (C) 2020 Signal Messenger, LLC.
// All rights reserved.
//
// SPDX-License-Identifier: GPL-3.0-only
//

// Generated by zkgroup/codegen/codegen.py - do not edit

#![allow(non_snake_case)]

use super::simpleapi;
use std::{panic, slice};
use crate::ffi::constants::FFI_RETURN_INTERNAL_ERROR;
"""

template_method_start = \
"""
#[no_mangle]
pub extern "C" fn %(function_name)s(
"""

template_method_decl_end = \
""") -> i32 {
"""

template_method_body_start = \
    """    let result = panic::catch_unwind(|| {
"""

template_method_body_end = \
    """
    match result {
        Ok(result) => result,
        Err(_) => FFI_RETURN_INTERNAL_ERROR,
    }
"""

def get_args(params, commaAtEnd):
    s = ""
    for param in params:
        s += param[1].snake() + ", "

    if len(s) != 0 and not commaAtEnd:
        s = s[:-2]
    return s


def print_method(c, m, static):
    s = ""

    if c.wrap_class == None:
        class_name = c.class_name
    else:
        class_name = c.wrap_class

    function_name = "FFI_" + class_name.camel() + "_" + m.method_name.lower_camel()
    s += template_method_start % {"function_name": function_name}

    # decl
    if not static:
        s += "    " + class_name.lower_camel() + ": *const u8,\n"
        s += "    " + class_name.lower_camel() + "Len: u32,\n"
    for param in m.params:
        if param[0] == "int":
            s += f"    {param[1].lower_camel()}: u32,\n"
        elif param[0] == "long":
            s += f"    {param[1].lower_camel()}: u64,\n"
        else:
            s += f"    {param[1].lower_camel()}: *const u8,\n"
            s += f"    {param[1].lower_camel()}Len: u32,\n"
    if m.return_type != "boolean":
        s += "    " + m.return_name.lower_camel() + "Out: *mut u8,\n" 
        s += "    " + m.return_name.lower_camel() + "Len: u32,\n" 
    s += template_method_decl_end

    # body
    s += template_method_body_start

    if not static:
        s += "        let " + class_name.snake() + ": &[u8] = unsafe { slice::from_raw_parts(%s, %sLen as usize) };\n" % (class_name.lower_camel(), class_name.lower_camel())
    for param in m.params:
        if param[0] == "int":
            s += f"        let {param[1].snake()} = {param[1].lower_camel()} as u32;\n"
        elif param[0] == "long":
            s += f"        let {param[1].snake()} = {param[1].lower_camel()} as u64;\n"
        else:
            s += f"        let {param[1].snake()}: &[u8] = unsafe {{ slice::from_raw_parts({param[1].lower_camel()}, {param[1].lower_camel()}Len as usize) }};\n"
    if m.return_type != "boolean":
        s += "        let %s: &mut [u8] = unsafe { slice::from_raw_parts_mut(%sOut, %sLen as usize) };\n" % (m.return_name.snake(), m.return_name.lower_camel(), m.return_name.lower_camel())

    if not static:
        if m.return_type != "boolean":
            s += """\n        simpleapi::%s_%s(%s, %s %s)\n""" % (class_name.camel(), m.method_name.lower_camel(), class_name.snake(), get_args(m.params, True), m.return_name.snake())
        else:
            s += """\n        simpleapi::%s_%s(%s, %s)\n""" % (class_name.camel(), m.method_name.lower_camel(), class_name.snake(), get_args(m.params, False))
    else:
        if m.return_type != "boolean":
            s += """\n        simpleapi::%s_%s(%s %s)\n""" % (class_name.camel(), m.method_name.lower_camel(), get_args(m.params, True), m.return_name.snake())
        else:
            s += """\n        simpleapi::%s_%s(%s)\n""" % (class_name.camel(), m.method_name.lower_camel(), get_args(m.params, False))
    s += "    });\n"

    s += template_method_body_end
    s += "}\n"

    return s

def print_class(c):
    s = ""
    for method in c.static_methods:
        s += print_method(c, method, True)
    for method in c.methods:
        s += print_method(c, method, False)
    return s


def produce_output(classes):
    s = file_header
    for c in classes:
        s += print_class(c)
    f = open("ffiapi/ffiapi.rs", "w")
    f.write(s)
    f.close()


file_header = \
"""//
// Copyright (C) 2020 Signal Messenger, LLC.
// All rights reserved.
//
// SPDX-License-Identifier: GPL-3.0-only
//

// Generated by zkgroup/codegen/codegen.py - do not edit

#![allow(non_snake_case)]

use crate::api;
use crate::common::constants::*;
use crate::common::simple_types; 
use crate::ffi::constants::*;
"""

template_method_start = \
"""
pub fn %s_%s(%s) -> i32 {"""

template_load = \
"""
    let %s: %s = match bincode::deserialize(%sIn) {
        Ok(result) => result,
        Err(_) => return %s,
    };
"""

template_ret = \
"""
    %sOut.copy_from_slice(&bincode::serialize(&%s).unwrap());"""

template_ret_simple = \
"""
    %sOut.copy_from_slice(&%s);"""


template_method_decl_end = \
"""
    FFI_RETURN_OK
}
"""

def get_args(c, m, class_name, static=True):
    s = ""
    if not static:
        s += class_name.lower_camel() + "In: &[u8], "

    for param in m.params:
        if param[0] == "int":
            s += param[1].lower_camel() + "In: u32,  "
        else:
            s += param[1].lower_camel() + "In: &[u8], "

    if m.return_type != "boolean":
        s += m.return_name.lower_camel() + "Out: &mut [u8], "

    if len(s) != 0:
        s = s[:-2]
    return s


def print_method(c, m, rustClasses, static):
    s = ""

    if c.wrap_class == None:
        class_name = c.class_name
    else:
        class_name = c.wrap_class
    # class_name = c.class_name

    s += template_method_start % (class_name.camel(), m.method_name.lower_camel(), get_args(c, m, class_name, static))

    if not static:
        if m.method_name.snake() != "check_valid_contents":
            error_name = "FFI_RETURN_INTERNAL_ERROR"
        elif m.verification:
            error_name = "FFI_RETURN_VERIFICATION_FAILED"
        else:
            error_name = "FFI_RETURN_INPUT_ERROR"
        if m.unused_self == True:
            s += template_load % ("_", rustClasses[class_name.snake()], class_name.lower_camel(), error_name)
        else:
            s += template_load % (class_name.snake(), rustClasses[class_name.snake()], class_name.lower_camel(), error_name)
    
    if m.verification:
        error_name = "FFI_RETURN_VERIFICATION_FAILED"
    else:
        error_name = "FFI_RETURN_INPUT_ERROR"

    for param in m.params:
        if param[0] == "int" or param[0] == "byte[]":
            s += "    let %s = %sIn;\n" % (param[1].snake(), param[1].lower_camel())
        elif param[1].snake() == "change_signature":
            s += """    let mut change_signature: simple_types::ChangeSignatureBytes = [0u8; SIGNATURE_LEN];
    change_signature.copy_from_slice(changeSignatureIn);\n""";
        elif param[1].snake() == "notary_signature":
            s += """    let mut notary_signature: simple_types::NotarySignatureBytes = [0u8; SIGNATURE_LEN];
    notary_signature.copy_from_slice(notarySignatureIn);\n""";
        else:
            s += template_load % (param[1].snake(), rustClasses[param[1].snake()], param[1].lower_camel(), error_name)

    s += m.rustCode

    if m.return_name.snake() == "change_signature" or m.return_name.snake() == "notary_signature" or \
       m.return_type == "byte[]":
        s += template_ret_simple % (m.return_name.lower_camel(), m.return_name.snake())
    elif m.return_name.snake() == "redemption_time":
        s += "\n    redemptionTimeOut.copy_from_slice(&redemption_time.to_be_bytes());"
    elif m.return_type != "boolean":
        s += template_ret % (m.return_name.lower_camel(), m.return_name.snake())

    s += template_method_decl_end
    return s

def print_class(c, rustClasses):
    s = ""
    for method in c.static_methods:
        s += print_method(c, method, rustClasses, True)
    for method in c.methods:
        s += print_method(c, method, rustClasses, False)
    return s


def produce_output(classes):

    rustClasses = {}
    for c in classes:
        if c.wrap_class == None:
            class_name = c.class_name
        else:
            class_name = c.wrap_class
        rustClasses[c.class_name.snake()] = c.rust_class_name

    s = file_header
    for c in classes:
        s += print_class(c, rustClasses)
    f = open("simpleapi/simpleapi.rs", "w")
    f.write(s)
    f.close()
